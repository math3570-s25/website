{
  "hash": "c4232aabb6cb1ec8110e0adf3c08ff00",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Wrangling - one data frame ðŸ› \"\nsubtitle: \"MATH/COSC 3570 Introduction to Data Science\"\nauthor: \"Dr. Cheng-Han Yu <br> Department of Mathematical and Statistical Sciences <br> Marquette University\"\n# date: \"February 26 2025\"\n# macros: _macros.tex # import a list of TeX/LaTeX definitions\nformat: \n  revealjs:\n    #     - \"macros.tex\"\n    html-math-method:\n      method: mathjax\n      url: \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"\n    # include-in-header:\n    highlight-style: arrow\n    code-block-bg: true\n    self-contained: false\n    slide-number: c/t\n    incremental: false\n    width: 1800\n    height: 1000\n    margin: 0.05\n    logo: \"https://upload.wikimedia.org/wikipedia/commons/e/e8/Marquette_Golden_Eagles_logo.svg\"\n    footer: \"[math3570-s25.github.io/website](https://math3570-s25.github.io/website/)\"\n    theme: [\"simple\", \"slides.scss\"]\n    multiplex: true\n    code-link: true\n    fig-cap-location: bottom\n    fig-align: center\n    transition: none ## fade slide convex concave zoom\n    code-line-numbers: false\n    title-slide-attributes:\n      data-background-color: \"#447099\"\n      # data-background-image: images/paper-texture.jpg\n      # data-background-size: cover\n      # data-background-color: \"#698ED5\"\neditor: source\nexecute:\n  freeze: true\n  echo: true\n---\n\n#  {visibility=\"hidden\"}\n\n\\def\\bx{\\mathbf{x}}\n\\def\\bg{\\mathbf{g}}\n\\def\\bw{\\mathbf{w}}\n\\def\\bbeta{\\boldsymbol \\beta}\n\\def\\bX{\\mathbf{X}}\n\\def\\by{\\mathbf{y}}\n\\def\\bH{\\mathbf{H}}\n\\def\\bI{\\mathbf{I}}\n\\def\\bS{\\mathbf{S}}\n\\def\\bW{\\mathbf{W}}\n\\def\\T{\\text{T}}\n\\def\\cov{\\mathrm{Cov}}\n\\def\\cor{\\mathrm{Corr}}\n\\def\\var{\\mathrm{Var}}\n\\def\\E{\\mathrm{E}}\n\\def\\bmu{\\boldsymbol \\mu}\n\\DeclareMathOperator*{\\argmin}{arg\\,min}\n\\def\\Trace{\\text{Trace}}\n\n\n\n\n\n\n## \n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](https://raw.githubusercontent.com/hadley/r4ds/main/diagrams/data-science/wrangle.png){fig-align='center' width=100%}\n:::\n:::\n\n\n::: notes\n- Welcome back\n- This week: introduce tools of tidyverse for data wrangling\n- learn how to easily clean or transform our data so that we can extract some important properties of the data, and the data are ready for visualization, modeling and analysis.\n:::\n<!-- # {background-color=\"#A7D5E8\"} -->\n\n\n\n\n# {background-color=\"#A7D5E8\" background-image=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/dplyr.png\" background-size=\"30%\" background-position=\"90% 50%\"}\n\n::: {.left}\n<h1> Grammar of Data Manipulation </h1>\n<!-- <h3>[htmlwidgets](http://www.htmlwidgets.org/): leaflet, dygraphs, networkD3</h3> -->\n:::\n\n::: notes\n- Starting this week, we are going to talk about Grammar of Data Manipulation or Grammar of Data Wrangling. \n- In particular, we are going to use the tidyverse package dplyr to manipulate or transform our data.\n- If you become a data scientist after college, you will find that you spend most of the time cleaning or wrangling your data because the raw data usually look ugly, big and unorganized, and you have to grab what you really need for your analysis. Once the data set is ready, fitting a machine learning model or run an algorithm is just couple lines of code. Very easy because nowadays, many models and algorithms have been wrapped in a function. You just need to call the function.\n- You may feel a little bored the coming two weeks because I think data wrangling is not as fun as data visualization. But we have no choice. It is a must-have skill to be a data scientist, and I believe you will not learn this in other courses, but in this course only, or maybe in my course only.\n- All right. Let's begin.\n:::\n\n\n\n## Grammar of Data Wrangling: [dplyr](https://dplyr.tidyverse.org/index.html) ðŸ“¦\n\n- based on the concepts of functions as **verbs** that manipulate data frames\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/12-dplyr-1/dplyr-part-of-tidyverse.png){fig-align='center' width=70%}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n- `mutate`: [*create*]{.green} new columns from the existing^[We can use `tibble::add_column()` to add one or more columns to an existing data frame.]\n- `filter`: pick *[rows matching criteria]{.green}*\n- `slice`: pick *[rows using index(es)]{.green}*\n- `distinct`: filter for [*unique* rows]{.green}\n- `select`: pick *[columns]{.green} by name*\n- `summarise`: reduce variables to values\n- `group_by`: for grouped operations\n- `arrange`: reorder rows\n- ... (many more)\n\n:::\n::::\n\n\n::: notes\n- So Grammar of Data Wrangling is based on the concepts of functions as **verbs** that manipulate data frames. Using these verbs in coding is simple, intuitive and straightforward. They let you know what you are doing on your data.\n- And the package that does this is called dplyr.\n- This package offers a variety of functions each of which is a verb, as listed here, mutate, filter, slice, distinct. Is distinct a verb?? \n- there is no rule without an exception\n- Anyway, we will be going through these functions that help us manipulate or transform our data. OK\n:::\n\n\n\n## Rules of **dplyr** Functions\n\n:::: {.red}\n\n::: {.large}\n\n- First argument is *always* a **data frame**\n\n- Subsequent arguments say what to do with that data frame\n\n- *Always* return a **data frame**\n\n- Don't modify in place\n\n:::\n\n::::\n\n\n::: notes\n- So there are four rules of dplyr functions.\n- First argument is *always* a **data frame**\n- Subsequent arguments say what to do with that data frame\n- *Always* return a **data frame**, so data frame in, data frame out.\n- Don't modify in place, meaning that when we apply a function of dplyr to the data, we are not changing that data frame. We have option to re-save our result, either overwrite the existing data frame that we have or as a separate object, but we are not modifying the data frame in place.\n:::\n\n\n## Data: US gun murders by state for 2010\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(murders <- read_csv(\"./data/murders.csv\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 5\n  state      abb   region population total\n  <chr>      <chr> <chr>       <dbl> <dbl>\n1 Alabama    AL    South     4779736   135\n2 Alaska     AK    West       710231    19\n3 Arizona    AZ    West      6392017   232\n4 Arkansas   AR    South     2915918    93\n5 California CA    West     37253956  1257\n6 Colorado   CO    West      5029196    65\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n::: notes\n- The data set we are going to use as an illustrative example is again the murders data set in the dslabs package with the book Intro to Data Science\n- It is of R base data frame type with 51 observations and 5 variables.\n- Notice that region variable here is a factor, which may not make sense and we can convert it into a character vector if needed.\n- And we can change its data type to modern tibble data frame, again use as_tibble() function.\n:::\n\n\n## Adding a New Variable (Column) with [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.html)\n\n- `dplyr::mutate()` takes\n  + a data frame as the 1st argument\n  + the name and values of the variable as the 2nd argument using format `name = values`.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(murders <- murders |>  \n     mutate(rate = total / population * 100000)) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 6\n  state      abb   region population total  rate\n  <chr>      <chr> <chr>       <dbl> <dbl> <dbl>\n1 Alabama    AL    South     4779736   135  2.82\n2 Alaska     AK    West       710231    19  2.68\n3 Arizona    AZ    West      6392017   232  3.63\n4 Arkansas   AR    South     2915918    93  3.19\n5 California CA    West     37253956  1257  3.37\n6 Colorado   CO    West      5029196    65  1.29\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n. . .\n\n- `total` and `population` inside the function are **not** defined in our R environment. \n\n- `dplyr` functions know to look for variables in the data frame provided in the 1st argument. \n\n\n\n\n::: notes\n- OK now let's begin playing the the data set.\n- First, we can add a New Variable into the existing data set with the function mutate().\n- Remember, variables are stored by columns, and so adding new variables means add more columns to the data set.\n- The function `mutate()` takes the data frame as a first argument and the name and values of the variable as a second argument using the convention `name = values`.\n- Here, I compute the murder rate as the total number of murders divided by population and times 100,000. So the rate means the incidence rate per 100,000 people\n- `total` and `population` inside the function are **not** defined in our R environment, but we didn't get an error.\n- Functions in **dplyr** know to look for variables in the data frame provided in the first argument. `total` will have the values in `murders_tbl$total`.\n- Now you can see the new data set has a new column variable `rate` shown in the last column. \n- Use relocate() to change column positions, using the same syntax as select() to make it easy to move blocks of columns at once.\n<!-- - `total` will have the values in `murders$total` -->\n\nmutate() creates new columns that are functions of existing variables. It can also modify (if the name is the same as an existing column) and delete columns (by setting their value to NULL).\nmutate(\n  .data,\n  ...,\n  .by = NULL,\n  .keep = c(\"all\", \"used\", \"unused\", \"none\"),\n  .before = NULL,\n  .after = NULL\n)\n\n:::\n\n\n\n## Filtering Observations (Rows) with [`filter()`](https://dplyr.tidyverse.org/reference/filter.html)\n\n- `dplyr::filter()` takes a\n  + data frame as the 1st argument\n  + *conditional* statement as the 2nd. (pick rows matching criteria)\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# filter the data table to only show the entries for which \n# the murder rate is lower than 0.7\nmurders |> \n    filter(rate < 0.7) #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 6\n  state         abb   region        population total  rate\n  <chr>         <chr> <chr>              <dbl> <dbl> <dbl>\n1 Hawaii        HI    West             1360301     7 0.515\n2 Iowa          IA    North Central    3046355    21 0.689\n3 New Hampshire NH    Northeast        1316470     5 0.380\n4 North Dakota  ND    North Central     672591     4 0.595\n5 Vermont       VT    Northeast         625741     2 0.320\n```\n\n\n:::\n:::\n\n\n::: notes\n- All right. We add columns by mutate() function, and we pick observations (rows) with filter() function.\n- `filter()` function again takes the data frame as the first argument and then the conditional statement as the second. \n- So we pick rows by matching the criteria of the conditional statement in the second argument of the filter() function.\n- For example, here I filter the data table to only show the obs for which the murder rate is lower than 0.71\nNote that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.\n:::\n\n\n\n## `filter()` for Many Conditions at Once\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |>  \n    filter(rate > 0.1 & rate < 0.7,  #<<\n           region == \"Northeast\")  #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 6\n  state         abb   region    population total  rate\n  <chr>         <chr> <chr>          <dbl> <dbl> <dbl>\n1 New Hampshire NH    Northeast    1316470     5 0.380\n2 Vermont       VT    Northeast     625741     2 0.320\n```\n\n\n:::\n:::\n\n::: notes\n- We can actually use several conditions at once to filter the observations\n- For example, here we want the observations whose murder rate is between 0.1 and 0.71, and their region is Northeast.\n- You can see that only two observations satisfy the conditions, New Hampshire and Vermont.\n- Use one single & to have a logical vector\n- You can also write rate >= 0.1, rate <= 0.71. This way we separate the condition rate >= 0.1 & rate <= 0.71 into 2 conditions. \n- Theoretically You can provide as many conditions as you want. The conditions are combined with &\n:::\n\n\n\n## Logical Operators\n\n|operator    | definition                   | operator                    | definition          |\n|------------|------------------------------|-----------------------------|---------------------|\n|`<`         | less than                    |`x`&nbsp;&#124;&nbsp;`y`     | `x` OR `y`          |\n|`<=`        |\tless than or equal to       |`is.na(x)`                   | if `x` is `NA`      |\n|`>`         | greater than                 |`!is.na(x)`                  | if `x` is not `NA`  |\n|`>=`        |\tgreater than or equal to    |`x %in% y`                   | if `x` is in `y`    |\n|`==`        |\texactly equal to            |`!(x %in% y)`                | if `x` is not in `y`|\n|`!=`        |\tnot equal to                |`!x`                         | not `x`             |\n|`x & y`     | `x` AND `y`                  |                             |                     |\n\n\n::: notes\n- We have talked about this. These are logical operators you can use in the conditions of the filter() function.\n:::\n\n\n\n\n## [`slice()`](https://dplyr.tidyverse.org/reference/slice.html) for Certain Rows using Indexes\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 3rd to 6th row\nmurders |> \n    slice(3:6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 6\n  state      abb   region population total  rate\n  <chr>      <chr> <chr>       <dbl> <dbl> <dbl>\n1 Arizona    AZ    West      6392017   232  3.63\n2 Arkansas   AR    South     2915918    93  3.19\n3 California CA    West     37253956  1257  3.37\n4 Colorado   CO    West      5029196    65  1.29\n```\n\n\n:::\n:::\n\n\n. . .\n\n:::{.question}\nHow do we subset rows using matrix indexing?\n:::\n\n. . .\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders[3:6, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 6\n  state      abb   region population total  rate\n  <chr>      <chr> <chr>       <dbl> <dbl> <dbl>\n1 Arizona    AZ    West      6392017   232  3.63\n2 Arkansas   AR    South     2915918    93  3.19\n3 California CA    West     37253956  1257  3.37\n4 Colorado   CO    West      5029196    65  1.29\n```\n\n\n:::\n:::\n\n::: notes\n- OK. Slice. We use slice() function to subset observations or rows using indexes.\n- Same as other functions, the first argument is a data frame, so I use the pipe operator sending murders_tbl data set to the slice function.\n- It is the same as treating a data drame as a matrix and subsetting the rows, which is the usual way we do before learning this function. \n- So here we extract row 3 to row 6 of the data set.\n- microbenchmark::microbenchmark(slice(murders_tbl, 3:6), murders_tbl[3:6, ])\n- You cannot(can?) write murders_tbl[3:6, ] as a function call. How?\nslice_head() and slice_tail() select the first or last rows.\nslice_sample() randomly selects rows.\nslice_min() and slice_max() select rows with highest or lowest values of a variable.\n:::\n\n\n## [`distinct()`](https://dplyr.tidyverse.org/reference/distinct.html) to Filter for Unique Rows\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Select only unique/distinct rows from a data frame\nmurders |> distinct(region)  ## default\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 1\n  region       \n  <chr>        \n1 South        \n2 West         \n3 Northeast    \n4 North Central\n```\n\n\n:::\n\n```{.r .cell-code}\nmurders |> distinct(region, .keep_all = TRUE) ## keep all other variables\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 6\n  state       abb   region        population total  rate\n  <chr>       <chr> <chr>              <dbl> <dbl> <dbl>\n1 Alabama     AL    South            4779736   135  2.82\n2 Alaska      AK    West              710231    19  2.68\n3 Connecticut CT    Northeast        3574097    97  2.71\n4 Illinois    IL    North Central   12830632   364  2.84\n```\n\n\n:::\n:::\n\n::: notes\n- We can use distinct() function to select only unique/distinct rows from a data frame.\n- For example here, we use variable region to decide the unique rows. By default, the function only gives us the unique values of the variable region. \n- Do you wonder why we have the order South, West, Northeast, and North Central?\n- Actually, these values are the values of some rows.\n- If we keep all variables, we see that the south is the south for Alabama, west for alaska, northeast for connecticut, and North central for illinois.\n- distinct() functions grabs rows that first has each of the unique values of region variable.\n- So Alabama is the first observation that has value South, Alaska is the first observation that has value West, Connecticut is the first observation that has value Northeast, and Illinois is the first observation that has value North Central. \n- microbenchmark::microbenchmark(distinct(murders_tbl, region), as_tibble(unique(murders_tbl$region)))\n:::\n\n\n\n## `distinct()` Grabs First Row of The Unique Value\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> distinct(region, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 6\n  state       abb   region        population total  rate\n  <chr>       <chr> <chr>              <dbl> <dbl> <dbl>\n1 Alabama     AL    South            4779736   135  2.82\n2 Alaska      AK    West              710231    19  2.68\n3 Connecticut CT    Northeast        3574097    97  2.71\n4 Illinois    IL    North Central   12830632   364  2.84\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> slice(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 6\n  state      abb   region population total  rate\n  <chr>      <chr> <chr>       <dbl> <dbl> <dbl>\n1 Alabama    AL    South     4779736   135  2.82\n2 Alaska     AK    West       710231    19  2.68\n3 Arizona    AZ    West      6392017   232  3.63\n4 Arkansas   AR    South     2915918    93  3.19\n5 California CA    West     37253956  1257  3.37\n```\n\n\n:::\n:::\n\n\n\n\n\n## Selecting Columns with [`select()`](https://dplyr.tidyverse.org/reference/select.html)\n\n- In `dplyr::select()`, the 1st argument is a data frame, followed by variable names being selected in the data.\n\n- **The order of variable names matters!**\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(murders)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"state\"      \"abb\"        \"region\"     \"population\" \"total\"     \n[6] \"rate\"      \n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# select three columns, assign this to a new object\nmurders |> select(region, rate, state)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 3\n  region  rate state     \n  <chr>  <dbl> <chr>     \n1 South   2.82 Alabama   \n2 West    2.68 Alaska    \n3 West    3.63 Arizona   \n4 South   3.19 Arkansas  \n5 West    3.37 California\n6 West    1.29 Colorado  \n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n\n::: notes\n- filter(), slice() and distinct()are functions for picking rows. \n- select() is a function for picking columns or variables.\n- Here, I select three columns region, rate, and state.\n- Notice that the order of variable names matters! The original data set has variable order \"state\"      \"abb\"        \"region\"     \"population\" \"total\"      \"rate\".\n- But the resulting data frame will have the variables or columns ordered as  region, rate, state because this is the order you specify in the select().\n- If you don't know the column names, you can select by position. murders_tbl %>% select(3, 6, 1)\n:::\n\n\n## `select()` to Exclude Variables\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## exclude variable population\nmurders |> select(-population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 5\n  state      abb   region total  rate\n  <chr>      <chr> <chr>  <dbl> <dbl>\n1 Alabama    AL    South    135  2.82\n2 Alaska     AK    West      19  2.68\n3 Arizona    AZ    West     232  3.63\n4 Arkansas   AR    South     93  3.19\n5 California CA    West    1257  3.37\n6 Colorado   CO    West      65  1.29\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n::: notes\n- If you want to exclude some variables, just provide a vector of variables you want to remove, and put a minus sign in front of it.\n- Here we remove the population variable.\n:::\n\n\n\n## `select()` a Range of Variables\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnames(murders)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"state\"      \"abb\"        \"region\"     \"population\" \"total\"     \n[6] \"rate\"      \n```\n\n\n:::\n\n```{.r .cell-code}\n## from region to rate\nmurders |> select(region:rate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 4\n  region population total  rate\n  <chr>       <dbl> <dbl> <dbl>\n1 South     4779736   135  2.82\n2 West       710231    19  2.68\n3 West      6392017   232  3.63\n4 South     2915918    93  3.19\n5 West     37253956  1257  3.37\n6 West      5029196    65  1.29\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n::: notes\n- We can also select a range of variables.\n- For example, we select all variables for region to rate by using region:rate, just as we create a sequence of numbers from 1 to 5 using 1:5.\n- murders_tbl %>% select(3:6)\n:::\n\n\n\n## `select()` Variables with Certain Characteristics\n\n- `starts_with()` is a [**tidy-select**](https://tidyselect.r-lib.org/index.html) helper function.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> select(starts_with(\"r\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 2\n  region  rate\n  <chr>  <dbl>\n1 South   2.82\n2 West    2.68\n3 West    3.63\n4 South   3.19\n5 West    3.37\n6 West    1.29\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n\n::: notes\n- We can also some helper functions to select variables with some condition.\n- For example, we can use a helper function starts_with() to select variables whose name starts with letter \"r\".\n- And so region and rate variables are selected.\n:::\n\n\n\n## `select()` Variables with Certain Characteristics\n- `ends_with()` is a [**tidy-select**](https://tidyselect.r-lib.org/reference/index.html) helper function.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> select(ends_with(\"ion\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 2\n  region population\n  <chr>       <dbl>\n1 South     4779736\n2 West       710231\n3 West      6392017\n4 South     2915918\n5 West     37253956\n6 West      5029196\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n::: notes\n- We can also select variables whose name ends with \"ion\"\n- And so region and population variables are selected.\n:::\n\n\n## [**tidy-select**](https://tidyselect.r-lib.org/reference/index.html) Helpers^[See help for any of these functions for more info, e.g. `?num_range`.]\n\n- `starts_with()`: Starts with a prefix\n- `ends_with()`: Ends with a suffix\n- `contains()`: Contains a literal string\n- `num_range()`: Matches a numerical range like x01, x02, x03\n- `one_of()`: Matches variable names in a character vector\n- `everything()`: Matches all variables\n- `last_col()`: Select last variable, possibly with an offset\n- `matches()`: Matches a regular expression (a sequence of symbols/characters expressing a string/pattern to be searched for within text)\n\n::: notes\n- Here is a list of select helpers.\n- I am not able to go through every helper in detail. But they can be very useful depending on your goal.\n- Absolutely check their help page to learn how to use them and review the examples in the help page. OK.\n:::\n\n\n\n## Rationale for Pipe Operator\n\n:::{.question}\nHow do we show three variables (state, region, rate) for states that have murder rates below 0.7?\n:::\n\n- Method 1: Define the intermediate object `new_table`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_table <- select(murders, state, region, rate) \nfilter(new_table, rate < 0.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  state         region         rate\n  <chr>         <chr>         <dbl>\n1 Hawaii        West          0.515\n2 Iowa          North Central 0.689\n3 New Hampshire Northeast     0.380\n4 North Dakota  North Central 0.595\n5 Vermont       Northeast     0.320\n```\n\n\n:::\n:::\n\n::: notes\n- Remember we talked about the pipe operator, right? But we haven't really used it often.\n- But it kinda make much sense to use the pipe operator for data manipulation using dplyr functions.\n- Because the first argument of dplyr function is always a data frame and its function output is also a data frame, which can be the input of another dplyr function.\n- So if we wanna manipulate our data set via several different actions using the dplyr functions step by step, pipe operator can be very useful. Let's see why.\n- How do we show three variables (state, region, rate) for states that have murder rate below 0.71?\n- We can first select three variables state, region, rate, and save the resulting output to an object new_table, and then apply filter() function on the new_table to get the observations having murder rate less than 0.71\n- In fact, the object new_table is unnecessary. The table is not what we want, and any object created in the R environment occupies some memory space. \n:::\n\n\n## Rationale for Pipe Operator\n\n:::{.question}\nHow do we show three variables (state, region, rate) for states that have murder rates below 0.7?\n:::\n\n- Method 2: Apply one function onto the other with no intermediate object\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## not so easy to read and understand\nfilter(select(murders, state, region, rate), rate < 0.7) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  state         region         rate\n  <chr>         <chr>         <dbl>\n1 Hawaii        West          0.515\n2 Iowa          North Central 0.689\n3 New Hampshire Northeast     0.380\n4 North Dakota  North Central 0.595\n5 Vermont       Northeast     0.320\n```\n\n\n:::\n:::\n\n::: notes\n- If we don't use new_table object, we can put the code select(murders_tbl, state, region, rate) directly on the first argument of filter() function as the data input.\n- This gives us the same resulting data frame. \n- However, the code is not very easy to read and understand because when we read the code from left to right, it starts with filter, and then select, but we actually do the selection first. Also, the second argument or the condition used in the filter() function is at the end of the code, which is far away from the function name at the beginning.\n:::\n\n\n\n## Rationale for Pipe Operator\n\n- The code that looks like a verbal description of what we want to do without intermediate objects:\n\n> **data > *select()* > data after selecting > *filter()* > data after selecting and filtering**\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> \n    select(state, region, rate) |>  \n    filter(rate < 0.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  state         region         rate\n  <chr>         <chr>         <dbl>\n1 Hawaii        West          0.515\n2 Iowa          North Central 0.689\n3 New Hampshire Northeast     0.380\n4 North Dakota  North Central 0.595\n5 Vermont       Northeast     0.320\n```\n\n\n:::\n:::\n\n::: notes\n- Pipe Operator let us write code that looks more like a description of what we want to do without intermediate objects.\n- We start with the original data set, then we select variables, and then we filter observations.\n- So our code can be like \nIt's more clear and intuitive, right?\n:::\n\n\n## Summarizing Data -- `summarize()`\n\n- `summarize()` provides a data frame that summarizes the statistics we compute.\n\n<!-- - The output is always a data frame. -->\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheights <- read_csv(\"./data/heights.csv\")\nglimpse(heights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 1,050\nColumns: 2\n$ sex    <chr> \"Male\", \"Male\", \"Male\", \"Male\", \"Male\", \"Female\", \"Female\", \"Feâ€¦\n$ height <dbl> 75, 70, 68, 74, 61, 65, 66, 62, 66, 67, 72, 72, 69, 68, 69, 66,â€¦\n```\n\n\n:::\n:::\n\n::: notes\n- The `summarize()` function in **dplyr** provides a way to compute summary statistics.\n- Again, its first argument and output are always data frames.\n- We are gonna use another data set heights in the dslabs package to demonstrate the usage of function.\n- The data set only has two variables, sex and height.\n- height is a variable, but heights is the data set\n:::\n\n\n## Summarizing Data -- `summarize()`\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(s <- heights |> \n    filter(sex == \"Female\") |> \n    summarize(avg = mean(height),  \n              stdev = sd(height),\n              med = median(height), \n              min = min(height)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 4\n    avg stdev   med   min\n  <dbl> <dbl> <dbl> <dbl>\n1  64.9  3.76  65.0    51\n```\n\n\n:::\n\n```{.r .cell-code}\ns$avg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 64.9\n```\n\n\n:::\n\n```{.r .cell-code}\ns$min\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 51\n```\n\n\n:::\n:::\n\n:::{.alert}\n`summarise()` produces a *new data frame* that is not any variant of the original data frame.\n:::\n\n\n::: notes\n- Suppose we want to find the mean and standard deviation of female height and store the two values as a data frame, we can start with the data set heights, then filter or grab the observations that have sex Female, and then with the filtered data, use the summarize function to create a data frame of two variables \"average\" and \"standard_deviation\" computed from the variable height. \n- You see that the resulting object s is a data frame with two variables. \n- Notice that `summarise()` changes the data frame entirely, it collapses rows down to a single summary statistic, and removes all columns that are irrelevant to the calculation. Basically, the resulting df is not any variant of the original df anymore.\n\n`summarise()` changes the data frame entirely, it collapses rows down to a single summary statistic, and removes all columns that are irrelevant to the calculation.\n:::\n\n\n## Summarizing Data -- `summarize()`\n\n- One variable `quans` that has 3 values. The output is a 3 by 1 data frame.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(s2 <- heights |>  \n    filter(sex == \"Female\") |> \n    summarize(quans = quantile(height, c(0.1, 0.5, 0.9))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 Ã— 1\n  quans\n  <dbl>\n1  61  \n2  65.0\n3  69  \n```\n\n\n:::\n:::\n\n\n::: notes\n- we will get a data frame with more than one row if the function we use in summarize() return a vector.\n- For example here, we compute the 01, 0.5, and 0.9 quantile of variable height, and call it quantiles. Then the resulting data frame will have 3 rows, basically a column vector with 3 elements.\nstr(s2)\n:::\n\n\n## Summarizing Data -- `summarize()` {visibility=\"hidden\"}\n\n- `summarize()` always returns a data frame, which might be problematic when we want to use it as a numeric value with other operations or functions.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(rate_df <- murders |> \n    summarize(rate = sum(total) / sum(population) * 100000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 Ã— 1\n   rate\n  <dbl>\n1  3.03\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(rate_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(rate_df, 3) ## want a (atomic) vector of length 3, but get a list of length 3!\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$rate\n[1] 3.03\n\n$rate\n[1] 3.03\n\n$rate\n[1] 3.03\n```\n\n\n:::\n:::\n\n::: notes\n- We use summarize() function and compute the variable rate. The result is a 1 by 1 data frame. \n:::\n\n\n## Summarizing Data -- `pull()`  {visibility=\"hidden\"}\n\n- `pull()` accesses values or extract a single column in a data frame.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrate_num <- rate_df |>  \n    pull()\nclass(rate_num)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(rate_num, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.03 3.03 3.03\n```\n\n\n:::\n:::\n\n. . .\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> select(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 1\n  total\n  <dbl>\n1   135\n2    19\n3   232\n4    93\n5  1257\n6    65\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n:::\n\n\n::: {.column width=\"50%\"}\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |> pull(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  135   19  232   93 1257   65   97   38   99  669  376    7   12  364  142\n[16]   21   63  116  351   11  293  118  413   53  120  321   12   32   84    5\n[31]  246   67  517  286    4  310  111   36  457   16  207    8  219  805   22\n[46]    2  250   93   27   97    5\n```\n\n\n:::\n:::\n:::\n::::\n\n\n::: notes\n- If we want a number or a vector in general, we can use pull() function with the variable name rate inside the function.\n- Basically, pull() extract a single column as a vector, not a data frame. It's like `$` for selecting a column. `murder_rate_df$rate`\n- If we wanna keep the pipe operation style, using pull() function looks nicer.\nmurder_rate_df %>% `$`(rate)\n- murders_tbl[\"total\"]: tibble\n- murders_tbl %>% select(total): tibble\n- murders_tbl[[\"total\"]]: vector\n- murders_tbl %>% pull(total): vector\n\n:::\n\n\n## Grouping -- `group_by()`\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n(heights_group <- heights |> \n     group_by(sex))  #<<\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,050 Ã— 2\n# Groups:   sex [2]\n  sex    height\n  <chr>   <dbl>\n1 Male       75\n2 Male       70\n3 Male       68\n4 Male       74\n5 Male       61\n6 Female     65\n# â„¹ 1,044 more rows\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(heights_group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"grouped_df\" \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n- `heights_group` is a **grouped data frame**.\n\n- Tibbles are similar, but see `Groups: sex [2]` after grouping data by `sex`.\n\n- `summarize()` behaves differently when acting on `grouped_df`.\n\n\n\n::: notes\n- A common operation in data exploration is to first split data into groups and then compute summaries for each group.\n- To group a data set by some variable, we can use group_by() function. \n- Here, we group the heights data set by the variable sex. \n- Outputs are similar, but we see `Groups: sex [2]` after grouping data by sex. [2] means there are two groups.\n- And now the heights_group data set has a new class called grouped_df.\n:::\n\n\n## Group and Summarize: `group_by()` + `summarize()`\n\n- `summarize()` applies the summarization to **each group separately**.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nheights |> \n    group_by(sex) |> \n    summarize(avg = mean(height), stdev = sd(height), \n              med = median(height), min = min(height))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 5\n  sex      avg stdev   med   min\n  <chr>  <dbl> <dbl> <dbl> <dbl>\n1 Female  64.9  3.76  65.0    51\n2 Male    69.3  3.61  69      50\n```\n\n\n:::\n:::\n\n. . .\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmurders |>  \n    group_by(region) |> \n    summarize(median_rate = median(rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 2\n  region        median_rate\n  <chr>               <dbl>\n1 North Central        1.97\n2 Northeast            1.80\n3 South                3.40\n4 West                 1.29\n```\n\n\n:::\n:::\n\n::: notes\n- The `summarize()` function applies the summarization to **each group separately**.\n- Here we use the same summarize() function and compute the average and sd of the variable height as we previous did. \n- But if the the data set is a grouped data frame grouped by sex, the summarized output will show the avg and sd for each group, make and female separately.\n- Another example is that we first group the murders data by region, then when we compute the median murder rate, it will get the median murder rate for each region.\n- This is quite helpful when we want to explore the relationship between numerical and categorical variables. Like here, we discover that the murder rate in the south is the highest.\n- You can absolutely include some statistics summary in your project proposal when you describe your data.\n:::\n\n\n## Sorting Rows in Data Frames -- [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html)\n\n- `arrange()` orders entire data tables.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## order the states by population size\nmurders |>  \n    arrange(population)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 6\n  state                abb   region        population total   rate\n  <chr>                <chr> <chr>              <dbl> <dbl>  <dbl>\n1 Wyoming              WY    West              563626     5  0.887\n2 District of Columbia DC    South             601723    99 16.5  \n3 Vermont              VT    Northeast         625741     2  0.320\n4 North Dakota         ND    North Central     672591     4  0.595\n5 Alaska               AK    West              710231    19  2.68 \n6 South Dakota         SD    North Central     814180     8  0.983\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n\n::: notes\n- For ordering entire data tables, the dplyr function `arrange()` is useful.\n- We get to decide which column to sort by.\n- If we want to sort the observations of murders data set by population size, we just need to pipe the data set into arrange function and specify population variable.\n- How do we do the same thing with base R grammar, not tidyverse grammar?\n- murders[order(murders$population), ]\n:::\n\n\n\n## Sorting Rows in Data Frames -- `arrange()`  {visibility=\"hidden\"}\n\n- The function `desc()` transforms a vector so that it is in descending order.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n## see the states by murder rate, from highest to lowest\nmurders |> \n    arrange(desc(rate))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51 Ã— 6\n  state                abb   region        population total  rate\n  <chr>                <chr> <chr>              <dbl> <dbl> <dbl>\n1 District of Columbia DC    South             601723    99 16.5 \n2 Louisiana            LA    South            4533372   351  7.74\n3 Missouri             MO    North Central    5988927   321  5.36\n4 Maryland             MD    South            5773552   293  5.07\n5 South Carolina       SC    South            4625364   207  4.48\n6 Delaware             DE    South             897934    38  4.23\n# â„¹ 45 more rows\n```\n\n\n:::\n:::\n\n::: notes\n- The function `desc()` transforms a vector so that it is in descending order.\n- With this function, we arrange states by murder rate in descending order.\n:::\n\n\n\n##\n\n::: {.lab}\n\n<span style=\"color:blue\"> **15-dplyr** </span>\n<!-- - Create the R script **lab13-dplyr.R** -->\n\nIn **lab.qmd** `## Lab 15` section, import the `murders.csv` data and \n\n1. Add **(mutate)** the variable `rate = total / population * 100000` to `murders` data (as I did).\n\n2. **Filter** states that are in *region Northeast or West* and their *murder rate is less than 1*.\n\n3. **Select** variables `state`, `region`, `rate`. \n\n- Print the output table after you do 1. to 3., and save it as object `my_states`.\n\n- **Group** `my_states` **by** `region`. Then **summarize** data by creating variables `avg` and `stdev` that compute the mean and standard deviation of `rate`. \n\n- **Arrange** the summarized table by `avg`.\n\n:::\n\n\n\n##\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n_______ <- _______ |> \n    mutate(_______) |> \n    filter(_______) |> \n    select(_______)\n\n_______ |>  \n    group_by(______) |> \n    summarize(______) |> \n    arrange(_______)\n```\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output .cell-output-stdout}\n\n```\n          state    region  rate\n1        Hawaii      West 0.515\n2         Idaho      West 0.766\n3         Maine Northeast 0.828\n4 New Hampshire Northeast 0.380\n5        Oregon      West 0.940\n6          Utah      West 0.796\n7       Vermont Northeast 0.320\n8       Wyoming      West 0.887\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 3\n  region      avg stdev\n  <fct>     <dbl> <dbl>\n1 West      0.781 0.164\n2 Northeast 0.509 0.278\n```\n\n\n:::\n:::\n\n:::\n\n::::\n\n\n# {background-color=\"#ffde57\" background-image=\"https://upload.wikimedia.org/wikipedia/commons/e/ed/Pandas_logo.svg\" background-size=\"40%\" background-position=\"90% 50%\"}\n\n\n::: {.left}\n<h1> Data Manipulation </h1>\n:::\n\n\n::: notes\nhttps://towardsdatascience.com/python-pandas-vs-r-dplyr-5b5081945ccb\n:::\n\n## \n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nimport numpy as np\nimport pandas as pd\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders = pd.read_csv('./data/murders.csv')\nmurders\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   state abb         region  population  total\n0                Alabama  AL          South     4779736    135\n1                 Alaska  AK           West      710231     19\n2                Arizona  AZ           West     6392017    232\n3               Arkansas  AR          South     2915918     93\n4             California  CA           West    37253956   1257\n5               Colorado  CO           West     5029196     65\n6            Connecticut  CT      Northeast     3574097     97\n7               Delaware  DE          South      897934     38\n8   District of Columbia  DC          South      601723     99\n9                Florida  FL          South    19687653    669\n10               Georgia  GA          South     9920000    376\n11                Hawaii  HI           West     1360301      7\n12                 Idaho  ID           West     1567582     12\n13              Illinois  IL  North Central    12830632    364\n14               Indiana  IN  North Central     6483802    142\n15                  Iowa  IA  North Central     3046355     21\n16                Kansas  KS  North Central     2853118     63\n17              Kentucky  KY          South     4339367    116\n18             Louisiana  LA          South     4533372    351\n19                 Maine  ME      Northeast     1328361     11\n20              Maryland  MD          South     5773552    293\n21         Massachusetts  MA      Northeast     6547629    118\n22              Michigan  MI  North Central     9883640    413\n23             Minnesota  MN  North Central     5303925     53\n24           Mississippi  MS          South     2967297    120\n25              Missouri  MO  North Central     5988927    321\n26               Montana  MT           West      989415     12\n27              Nebraska  NE  North Central     1826341     32\n28                Nevada  NV           West     2700551     84\n29         New Hampshire  NH      Northeast     1316470      5\n30            New Jersey  NJ      Northeast     8791894    246\n31            New Mexico  NM           West     2059179     67\n32              New York  NY      Northeast    19378102    517\n33        North Carolina  NC          South     9535483    286\n34          North Dakota  ND  North Central      672591      4\n35                  Ohio  OH  North Central    11536504    310\n36              Oklahoma  OK          South     3751351    111\n37                Oregon  OR           West     3831074     36\n38          Pennsylvania  PA      Northeast    12702379    457\n39          Rhode Island  RI      Northeast     1052567     16\n40        South Carolina  SC          South     4625364    207\n41          South Dakota  SD  North Central      814180      8\n42             Tennessee  TN          South     6346105    219\n43                 Texas  TX          South    25145561    805\n44                  Utah  UT           West     2763885     22\n45               Vermont  VT      Northeast      625741      2\n46              Virginia  VA          South     8001024    250\n47            Washington  WA           West     6724540     93\n48         West Virginia  WV          South     1852994     27\n49             Wisconsin  WI  North Central     5686986     97\n50               Wyoming  WY           West      563626      5\n```\n\n\n:::\n:::\n\n## New Variables [`.assign`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.assign.html)\n\n- `dplyr::mutate()`\n\n- [Have to use `murders.total` and `murders.population` instead of `total` and `popution`.]{.green}\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders = murders.assign(\n    rate = round(murders.total / murders.population * 100000, 2))\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders.head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        state abb region  population  total  rate\n0     Alabama  AL  South     4779736    135  2.82\n1      Alaska  AK   West      710231     19  2.68\n2     Arizona  AZ   West     6392017    232  3.63\n3    Arkansas  AR  South     2915918     93  3.19\n4  California  CA   West    37253956   1257  3.37\n```\n\n\n:::\n:::\n\n\n\n## Filter Rows [`.query`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html)\n\n-  `dplyr::filter()`\n\n- [Conditions must be a **string** to be evaluated!]{.green}\n\n- [Cannot write `murders.rate`, and should use `rate`. ]{.green}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders.query(expr=\"rate < 0.7\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            state abb         region  population  total  rate\n11         Hawaii  HI           West     1360301      7  0.51\n15           Iowa  IA  North Central     3046355     21  0.69\n29  New Hampshire  NH      Northeast     1316470      5  0.38\n34   North Dakota  ND  North Central      672591      4  0.59\n45        Vermont  VT      Northeast      625741      2  0.32\n```\n\n\n:::\n:::\n\n\n\n\n\n## Select Columns [`.filter`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.filter.html)\n\n-  `dplyr::select()`\n\n- [Have to be strings]{.green}\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders.filter(items=['region', 'rate', 'state'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           region   rate                 state\n0           South   2.82               Alabama\n1            West   2.68                Alaska\n2            West   3.63               Arizona\n3           South   3.19              Arkansas\n4            West   3.37            California\n5            West   1.29              Colorado\n6       Northeast   2.71           Connecticut\n7           South   4.23              Delaware\n8           South  16.45  District of Columbia\n9           South   3.40               Florida\n10          South   3.79               Georgia\n11           West   0.51                Hawaii\n12           West   0.77                 Idaho\n13  North Central   2.84              Illinois\n14  North Central   2.19               Indiana\n15  North Central   0.69                  Iowa\n16  North Central   2.21                Kansas\n17          South   2.67              Kentucky\n18          South   7.74             Louisiana\n19      Northeast   0.83                 Maine\n20          South   5.07              Maryland\n21      Northeast   1.80         Massachusetts\n22  North Central   4.18              Michigan\n23  North Central   1.00             Minnesota\n24          South   4.04           Mississippi\n25  North Central   5.36              Missouri\n26           West   1.21               Montana\n27  North Central   1.75              Nebraska\n28           West   3.11                Nevada\n29      Northeast   0.38         New Hampshire\n30      Northeast   2.80            New Jersey\n31           West   3.25            New Mexico\n32      Northeast   2.67              New York\n33          South   3.00        North Carolina\n34  North Central   0.59          North Dakota\n35  North Central   2.69                  Ohio\n36          South   2.96              Oklahoma\n37           West   0.94                Oregon\n38      Northeast   3.60          Pennsylvania\n39      Northeast   1.52          Rhode Island\n40          South   4.48        South Carolina\n41  North Central   0.98          South Dakota\n42          South   3.45             Tennessee\n43          South   3.20                 Texas\n44           West   0.80                  Utah\n45      Northeast   0.32               Vermont\n46          South   3.12              Virginia\n47           West   1.38            Washington\n48          South   1.46         West Virginia\n49  North Central   1.71             Wisconsin\n50           West   0.89               Wyoming\n```\n\n\n:::\n:::\n\n\n## Grouping [`.groupby`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html) + [`.agg`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.agg.html)\n\n- `dplyr::group_by() + dplyr::summarize()`\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nheights = pd.read_csv('./data/heights.csv')\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nheights.groupby(by='sex')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<pandas.core.groupby.generic.DataFrameGroupBy object at 0x362dfeff0>\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\n## a data frame\nheights.groupby(by='sex').agg(func=['mean', 'std', 'median', 'min'])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           height                           \n             mean       std     median   min\nsex                                         \nFemale  64.939424  3.760656  64.980315  51.0\nMale    69.314755  3.611024  69.000000  50.0\n```\n\n\n:::\n:::\n\n\n\n## Sorting [`.sort_values`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html)\n\n\n- `dplyr::arrange()`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders.sort_values('population').head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   state abb         region  population  total   rate\n50               Wyoming  WY           West      563626      5   0.89\n8   District of Columbia  DC          South      601723     99  16.45\n45               Vermont  VT      Northeast      625741      2   0.32\n34          North Dakota  ND  North Central      672591      4   0.59\n1                 Alaska  AK           West      710231     19   2.68\n```\n\n\n:::\n:::\n\n. . .\n\n- `dplyr::arrange(desc())`\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.python .cell-code}\nmurders.sort_values('rate', ascending = False).head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   state abb         region  population  total   rate\n8   District of Columbia  DC          South      601723     99  16.45\n18             Louisiana  LA          South     4533372    351   7.74\n25              Missouri  MO  North Central     5988927    321   5.36\n20              Maryland  MD          South     5773552    293   5.07\n40        South Carolina  SC          South     4625364    207   4.48\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}