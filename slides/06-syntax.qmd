---
title: 'Basic R/Python `r fontawesome::fa("r-project")`  `r fontawesome::fa("python")` '
subtitle: "MATH/COSC 3570 Introduction to Data Science"
author: "Dr. Cheng-Han Yu <br> Department of Mathematical and Statistical Sciences <br> Marquette University"
# date: "`r format(Sys.time(), '%B %d %Y')`"
# macros: _macros.tex # import a list of TeX/LaTeX definitions
format: 
  revealjs:
    #     - "macros.tex"
    html-math-method:
      method: mathjax
      url: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    # include-in-header:
    highlight-style: github
    code-block-bg: true
    self-contained: false
    slide-number: c/t
    incremental: false
    width: 1800
    height: 1000
    margin: 0.05
    logo: "https://upload.wikimedia.org/wikipedia/commons/e/e8/Marquette_Golden_Eagles_logo.svg"
    footer: "[math3570-s24.github.io/website](https://math3570-s24.github.io/website/)"
    theme: ["simple", "slides.scss"]
    echo: false
    multiplex: true
    code-link: true
    fig-cap-location: bottom
    fig-align: center
    transition: none ## fade slide convex concave zoom
    title-slide-attributes:
      data-background-color: "#447099"
      # data-background-image: images/paper-texture.jpg
      # data-background-size: cover
      # data-background-color: "#698ED5"
editor: source
execute:
  freeze: true
  eval: true
fig-cap-location: bottom
---

#  {visibility="hidden"}

\def\bx{\mathbf{x}}
\def\bg{\mathbf{g}}
\def\bw{\mathbf{w}}
\def\bbeta{\boldsymbol \beta}
\def\bX{\mathbf{X}}
\def\by{\mathbf{y}}
\def\bH{\mathbf{H}}
\def\bI{\mathbf{I}}
\def\bS{\mathbf{S}}
\def\bW{\mathbf{W}}
\def\T{\text{T}}
\def\cov{\mathrm{Cov}}
\def\cor{\mathrm{Corr}}
\def\var{\mathrm{Var}}
\def\E{\mathrm{E}}
\def\bmu{\boldsymbol \mu}
\DeclareMathOperator*{\argmin}{arg\,min}
\def\Trace{\text{Trace}}



```{r}
#| label: setup
#| include: false
#| eval: true
library(countdown)
library(emo)
library(knitr)
library(gt)
library(gtExtras)
library(ggplot2)
library(tidyverse)
library(tidymodels)
library(fontawesome)
library(rmarkdown)
library(reticulate)
# library(field)
# library(ISLR2)
# library(genridge)
# library(glmnet)
# library(gam)
# library(splines)
# library(MASS)

# library(ElemStatLearn)
knitr::opts_chunk$set(
    fig.asp = 0.618,
    fig.align = "center",
    out.width = "100%",
    fig.retina = 10,
    fig.path = "images/06-syntax/",
    message = FALSE,
    global.par = TRUE
)
options(
  htmltools.dir.version = FALSE,
  dplyr.print_min = 6, 
  dplyr.print_max = 6,
  tibble.width = 80,
  width = 80,
  digits = 3
  )
hook_output <- knitr::knit_hooks$get("output")
knitr::knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }
  # paste these lines together
  x <- paste(c(x, ""), collapse = "\n")
  hook_output(x, options)
})
```

```{r}
library(reticulate)
py_install("pandas")
py_install("matplotlib")
```

```{python}
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
```

<!-- # Basic R and Python  -->

## Run Code in Console

:::: {.columns}

::: {.column width="50%"}


- `reticulate::repl_python()` to Python.

```{r}
#| fig-align: "center"
#| out-width: 70%
knitr::include_graphics("./images/06-syntax/console-r.png")
```

```{r}
#| fig-align: "center"
knitr::include_graphics("./images/06-syntax/console-py.png")
```

:::


::: {.column width="50%"}

::: {.fragment}

- `quit` or `exit` to change Console back to R.

```{r}
knitr::include_graphics("./images/06-syntax/console-py-quit.png")
```

:::
:::


::::



## Arithmetic and Logical Operators


:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```

```{r}
#| echo: true
2 + 3 / (5 * 4) ^ 2
5 == 5.00
# 5 and 5L are of the same value too
# 5 is of type double; 5L is integer
5 == 5L
typeof(5L)
!TRUE == FALSE
```

:::


::: {.column width="50%"}

::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```

```{python}
#| echo: true
2 + 3 / (5 * 4) ** 2
5 == 5.00
5 == int(5)
type(int(5))
not True == False
```
:::
:::


::::


::: notes
repl_python()
:::

## Arithmetic and Logical Operators


:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```

**Type coercion**: When doing AND/OR comparisons, all nonzero values are treated as `TRUE` and 0 as `FALSE`.

```{r}
#| echo: true
-5 | 0
1 & 1
2 | 0
```


:::


::: {.column width="50%"}
::: {.fragment}

```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```

`bool()` converts nonzero numbers to `True` and zero to `False`


```{python}
#| echo: true
-5 | 0
1 & 1
bool(2) | bool(0)
```
:::
:::

::::


## Math Functions


:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```

Math functions in R are built-in.

```{r}
#| echo: true
sqrt(144)
exp(1)
sin(pi/2)
log(32, base = 2)
abs(-7)
```

```{r}
#| echo: true
# R comment
```

:::


::: {.column width="50%"}
::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```

Need to import math library in Python.


```{python}
#| echo: true
import math
math.sqrt(144)
math.exp(1)
math.sin(math.pi/2)
math.log(32, 2)
abs(-7)
```

```{python}
#| echo: true
# python comment
```

:::

:::

::::


##

:::: {.columns}

::: {.column width="50%"}
```{r}
knitr::include_graphics("./images/06-syntax/cat_comment.png")
```
:::



::: {.column width="50%"}
```{r}
knitr::include_graphics("./images/06-syntax/stop_comment.png")
```
:::
::::



## Variables and Assignment


:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```

Use `<-` to do **assignment**. [Why](https://colinfay.me/r-assignment/)

```{r}
#| echo: true
## we create an object, value 5, 
## and call it x, which is a variable
x <- 5
x
(x <- x + 6)
x == 5
log(x)
```

:::


::: {.column width="50%"}
::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```

Use `=` to do assignment.

```{python}
#| echo: true
x = 5
x
x = x + 6
x
x == 5
math.log(x)
```

:::
:::
::::


## Object Types


:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```

**`character`**, **`double`**, **`integer`** and **`logical`**.

```{r}
#| echo: true
typeof(5)
```

```{r}
#| echo: true
typeof(5L)
```

```{r}
#| echo: true
typeof("I_love_data_science!")
```

```{r}
#| echo: true
typeof(1 > 3)
```

```{r}
#| echo: true
is.double(5L)
```

:::


::: {.column width="50%"}
::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```


**`str`**, **`float`**, **`int`** and **`bool`**.


```{python}
#| echo: true
type(5.0)
type(5)
type("I_love_data_science!")
type(1 > 3)
type(5) is float
```

:::
:::
::::

::: notes
python long (long integers, they can also be represented in octal and hexadecimal)
:::




# R Data Structures {background-color="#A7D5E8"}

- ### Vector
- ### Factor
- ### List
- ### Matrix
- ### Data Frame


##
:::: {.columns}

::: {.column width="50%"}
```{r}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/vectors/summary-tree-atomic.png")
```
:::



::: {.column width="50%"}
```{r}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/vectors/summary-tree.png")
```
:::
::::

- Variable defined previously is a **scalar** value, or in fact a (atomic) **vector of length one**.


## (Atomic) Vector
- To create a vector, use `c()`, short for *concatenate* or *combine*.
- **All** elements of a vector must be of the **same type**. 

:::: {.columns}

::: {.column width="50%"}
```{r}
#| label: vector1
#| echo: true
(dbl_vec <- c(1, 2.5, 4.5)) 
(int_vec <- c(1L, 6L, 10L))
## TRUE and FALSE can be written as T and F
(log_vec <- c(TRUE, FALSE, F))  
(chr_vec <- c("pretty", "girl"))
```
:::



::: {.column width="50%"}
```{r}
#| label: vector2
#| echo: true
## check how many elements in a vector
length(dbl_vec) 
## check a compact description of 
## any R data structure
str(dbl_vec) 
```
:::
::::




## Sequence of Numbers
- Use `:` to create a sequence of *integers*.
- Use `seq()` to create a sequence of numbers of type `double` with more options.
<!-- - Vectors created by `seq()` are  -->

```{r}
#| echo: true
#| label: seq
(vec <- 1:5) 
typeof(vec)

# a sequence of numbers from 1 to 10 with increment 2
(seq_vec <- seq(from = 1, to = 10, by = 2))
typeof(seq_vec)
```

```{r}
#| echo: false
#| eval: false
# a sequence of numbers from 1 to 10
# with 12 elements
seq(from = 1, to = 10, length.out = 12)
```


## Operations on Vectors
- We can do any operations on vectors as we do on a *scalar* variable (vector of length 1).

:::: {.columns}

::: {.column width="50%"}
```{r}
#| echo: true
#| label: vector-arithmetic1
# Create two vectors
v1 <- c(3, 8)
v2 <- c(4, 100) 

## All operations happen element-wisely
# Vector addition
v1 + v2
# Vector subtraction
v1 - v2
```
:::


::: {.column width="50%"}
```{r}
#| echo: true
#| label: vector-arithmetic2
# Vector multiplication
v1 * v2
# Vector division
v1 / v2
sqrt(v2)
```
:::
::::


## Recycling of Vectors
- If we apply arithmetic operations to two vectors of **unequal** length, the elements of the shorter vector will be **recycled** to complete the operations.
<!-- - Beware of recycling! -->
<!-- - The concept of *recycling* helps us write more concise code. -->

```{r}
#| echo: true
#| label: recycle
v1 <- c(3, 8, 4, 5)
# The following 2 operations are the same
v1 * 2
v1 * c(2, 2, 2, 2)
v3 <- c(4, 11)
v1 + v3  ## v3 becomes c(4, 11, 4, 11) when doing the operation
```


## Subsetting Vectors
- To extract element(s) in a vector, we use a pair of brackets `[]` with element indexing.
- The indexing **starts with 1**.

:::: {.columns}

::: {.column width="50%"}
```{r}
#| echo: true
#| label: subsetting1
v1
v2
## The 3rd element
v1[3] 
```
:::


::: {.column width="50%"}
```{r}
#| echo: true
#| label: subsetting2
v1[c(1, 3)]
v1[1:2]
## extract all except a few elements
## put a negative sign before the vector of 
## indices
v1[-c(2, 3)] 
```

```{r, echo = FALSE, eval=FALSE}
#| echo: false
#| eval: false
x <- c(1, 5, 2, 6)
names(x) <- letters[1:4]
x["c"]
```
:::
::::

## Factor
- A vector of type `factor` can be *ordered in a meaningful way.* 
- Create a factor by `factor()`. It is a type of **integer**, not **character**. `r emo::ji('astonished')`  `r emo::ji('roll_eyes')` 

```{r}
#| echo: true
#| label: factor
## Create a factor from a character vector using function factor()
(fac <- factor(c("med", "high", "low")))
typeof(fac)  ## The type is integer.
str(fac)  ## The integers show the level each element in vector fac belongs to.
```

. . .

```{r}
#| echo: true
#| label: order_factor
order_fac <- factor(c("med", "high", "low"),
                    levels = c("low", "med", "high"))
str(order_fac)
```


::: notes
levels(fac) ## Each level represents an integer, ordered from the vector alphabetically.
:::


## List (Generic Vectors)
```{r}
#| out-width: "18%"
knitr::include_graphics("https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/vectors/summary-tree.png")
```


- Lists are different from (atomic) vectors: Elements can be of **any type**, including lists.

- Construct a list by using **`list()`**.


:::: {.columns}

::: {.column width="50%"}
```{r}
#| echo: true
#| label: list1
## a list of 3 elements of different types
x_lst <- list(idx = 1:3, 
              "a", 
              c(TRUE, FALSE))
```
```{r, echo=FALSE}
x_lst
```
:::

::: {.column width="50%"}
```{r}
#| echo: true
#| label: list2
str(x_lst)
names(x_lst)
length(x_lst)
```
:::
::::


## Subsetting a List

:::: {.columns}

::: {.column width="50%"}
<br>
**Return an <span style="color:red"> element </span> of a list**

```{r}
#| echo: true
#| label: list3
## subset by name (a vector)
x_lst$idx  
## subset by indexing (a vector)
x_lst[[1]]  
typeof(x_lst$idx)
```
:::

::: {.column width="50%"}
::: {.fragment}
<br>
**Return a <span style="color:red"> sub-list </span> of a list**


```{r}
#| echo: true
#| label: list4
## subset by name (still a list)
x_lst["idx"]  
## subset by indexing (still a list)
x_lst[1]  
typeof(x_lst["idx"])
```
:::
:::
::::

::: notes
- This is where we should pay more attention to. When we subset a list, it may return an element of the list, or it returns a sub-list of the list.
- Let's see how it happens. 
- This is our x_lst. We can subset a list by name or by indexing. 
- Suppose we want the first element of the list, we can get it by its name using x_lst$idx.
- We can also obtain it by using indexing like x_lst[[1]] because we want the first element.
- Notice that the way we subset a list returns an integer vector, the real first element of the list, not a list. 
- Let's see another case on the right.
- We can also subset by name using single pair of brackets, and put the name inside the brackets.
- Or we can subset by indexing, again using single pair of brackets.
- And you see what happened? The way we subset a list here returns a sub-list, not the element itself. 
- So please be careful when subsetting a list. 
- If you want a vector, use these ways. If you want to keep it as a list, use these ways.
:::

##
```{r}
#| label: list_condiment
knitr::include_graphics("./images/06-syntax/list_condiment.png")
```

::: notes
pepper packet
pepper shaker
:::



##
> If list `x` is a train carrying objects, then `x[[5]]` is
> the object in car 5; `x[4:6]` is a train of cars 4-6.
>
> --- \@RLangTip, <https://twitter.com/RLangTip/status/268375867468681216>

```{r}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/subsetting/train.png")
```

```{r}
knitr::include_graphics("https://raw.githubusercontent.com/hadley/adv-r/master/diagrams/subsetting/train-single.png")
```


## Matrix

- A matrix is a *two-dimensional analog of a vector* with **attribute** `dim`.
- Use command `matrix()` to create a matrix.
```{r}
#| label: matrix1
#| tidy: false
#| echo: true
## Create a 3 by 2 matrix called mat
(mat <- matrix(data = 1:6, nrow = 3, ncol = 2)) 
dim(mat); nrow(mat); ncol(mat)
```


::: notes
```{r matrix2, tidy=FALSE}
# elements are arranged by row
matrix(data = 1:6, 
       nrow = 3, 
       ncol = 2, 
       byrow = TRUE) #<<
attributes(mat)
```
:::


## Row and Column Names
:::: {.columns}

::: {.column width="50%"}
```{r}
#| label: matrix3
#| echo: true
mat
## assign row names and column names
rownames(mat) <- c("A", "B", "C")
colnames(mat) <- c("a", "b")
mat
```
:::

::: {.column width="50%"}
```{r matrix4}
#| label: matrix4
#| echo: true
rownames(mat)
colnames(mat)
attributes(mat)
```
:::
::::




## Subsetting a Matrix
- Use the same indexing approach as vectors on rows and columns.
- Use comma `,` to separate row and column index.
- `mat[2, 2]` extracts the element of the second row and second column.


:::: {.columns}

::: {.column width="50%"}
```{r}
#| label: matrix-idx1
#| echo: true
mat
## all rows and 2nd column
## leave row index blank
## specify 2 in coln index
mat[, 2]
```
:::


::: {.column width="50%"}
```{r}
#| label: matrix-idx2
#| echo: true
## 2nd row and all columns
mat[2, ] 
## The 1st and 3rd rows and the 1st column
mat[c(1, 3), 1] 
```
:::
::::

## Binding Matrices

- `cbind()` (binding matrices by adding columns)

- `rbind()` (binding matrices by adding rows)
  
- When matrices are combined by columns (rows), they should have the same number of rows (columns).

:::: {.columns}

::: {.column width="50%"}
```{r}
#| label: matrix-cbind
#| echo: true
mat
mat_c <- matrix(data = c(7,0,0,8,2,6), 
                nrow = 3, ncol = 2)
## should have the same number of rows
cbind(mat, mat_c)  
```
:::

::: {.column width="50%"}
```{r}
#| label: matrix-rbind
#| echo: true
mat_r <- matrix(data = 1:4, 
                nrow = 2, 
                ncol = 2)
## should have the same number of columns
rbind(mat, mat_r)  
```
:::
::::





## Data Frame: The Most Common Way of Storing Datasets
- A data frame is of type **list** of *equal-length* vectors, having a *2-dimensional* structure.
- More general than matrix: *Different columns can have different types*.
- Use `data.frame()` that takes *named* vectors as input "element".


:::: {.columns}

::: {.column width="50%"}
```{r}
#| label: dataframe1
#| echo: true
## data frame w/ an dbl column named age
## and char column named gender.
(df <- data.frame(age = c(19, 21, 40), 
                  gen = c("m","f", "m")))

## a data frame has a list structure
str(df)  
```
:::

::: {.column width="50%"}

```{r}
#| label: dataframe2
#| echo: true
## must set column names
## or they are ugly and non-recognizable
data.frame(c(19,21,40), c("m","f","m")) 
```
:::
::::


## Properties of Data Frames

Data frame has properties of matrix and list.



:::: {.columns}

::: {.column width="40%"}

```{r}
#| label: df-fcns
#| echo: true
names(df)  ## df as a list
colnames(df)  ## df as a matrix
length(df) ## df as a list
ncol(df) ## df as a matrix
dim(df) ## df as a matrix
```
:::


::: {.column width="60%"}

```{r}
#| label: df-bind
#| echo: true
## rbind() and cbind() can be used on df
df_r <- data.frame(age = 10, 
                   gen = "f")
rbind(df, df_r)
df_c <- 
    data.frame(col = c("red","blue","gray"))
(df_new <- cbind(df, df_c))
```

:::
::::


## Subsetting a Data Frame

Can use either list or matrix subsetting methods.

:::: {.columns}

::: {.column width="50%"}

```{r}
#| label: df-subset1
#| echo: true
df_new
## Subset rows
df_new[c(1, 3), ]
## select the row where age == 21
df_new[df_new$age == 21, ]
```
:::

::: {.column width="50%"}
```{r, echo=1:6, eval=1:6}
#| label: df-subset2
#| echo: true
## Subset columns
## like a list
df_new$age
df_new[c("age", "gen")] 
## like a matrix
df_new[, c("age", "gen")]
```
:::
::::




::: notes
```{r}
df_new[c(1, 3), ]
str(df["age"])  ## a data frame with one column
str(df[, "age"])  ## becomes a vector by default
```
:::


##
:::::{.lab}

<span style="color:blue"> **05-R Data Type Summary** </span>

<!-- - Create a R script named **lab03-datatype.R**. -->
In **lab.qmd** Lab 5,

- Create R objects vector `v1`, factor `f2`, list `l3`, matrix `m4` and data frame `d5`.

- Check `typeof()` and `class()` of those objects, and create a list having the output below.

:::: {.columns}

::: {.midi}
::: {.column width="50%"}

```{r}
#| class-output: "my_classfull"
#| echo: true
#| eval: false

v1 <- __________
f2 <- __________
l3 <- __________
m4 <- __________
d5 <- __________
v <- c(type = typeof(v1), class = class(v1))
f <- c(type = __________, class = _________)
l <- c(type = __________, class = _________)
m <- c(type = __________, class = _________)
d <- c(type = __________, class = _________)
____(vec    =   v,
     ______ = ___,
     ______ = ___,
     ______ = ___,
     ______ = ___)
```
:::




::: {.column width="50%"}
```{r}
#| class-output: "my_classfull"
v <- c(type = typeof(v1), class = class(v1))
f <- c(type = typeof(fac), class = class(fac))
l <- c(type = typeof(x_lst), class = class(x_lst))
m <- c(type = typeof(mat), class = class(mat))
d <- c(type = typeof(df), class = class(df))
list(vec = v,
     fac = f,
     lst = l,
     mat = m,
     df = d)
```
:::
:::
::::
:::::



# Python Data Structures  {background-color="#ffde57"}

- ### List
- ### Tuple
- ### Dictionary


<!-- ## Change Console to Python -->

<!-- - Type `reticulate::repl_python()` to change Console to Python. -->

<!-- - Type `quit` or `exit` to change Console back to R. -->

## Python Lists

- Python has *numbers* and *strings*, but no built-in vector structure.
- To create a sequence type of structure, we can use a **list** that can save several elements in an single object. 
- To create a list in Python, we use `[]`.

:::: {.columns}

::: {.column width="50%"}
```{python}
#| label: py-lst
#| echo: true
lst_num = [0, 2, 4] 
lst_num
type(lst_num)
len(lst_num)
```
:::


::: {.column width="50%"}

List elements can have [*different types*]{style="color:green"}!

```{python}
#| label: py-lst1
#| echo: true
lst = ['data', 'math', 34, True]
lst
```
:::
::::




## Subsetting Lists

:::: {.columns}

::: {.column width="50%"}
- Indexing in Python **always starts at 0**!
- `0`: the 1st element

```{python}
#| echo: true
lst
lst[0]
type(lst[0]) ## not a list
```

- `-1`: the last element

```{python}
#| echo: true
lst[-2]
```

:::


::: {.column width="50%"}

- `[a:b]`: the (a+1)-th to b-th elements

```{python}
#| echo: true
lst[1:4]
type(lst[1:4]) ## a list
```

- `[a:]`: elements from the (a+1)-th to the last

```{python}
#| label: py-lst-subset2
#| echo: true
lst[2:]
```

:::
::::

::: {.question}
What does `lst[0:1]` return? Is it a list?
:::


::: notes

::: {.question}
What does `lst[0:1]` return? Is it a list?
:::

:::


## Lists are Mutable

Lists are **changed in place**!




:::: {.columns}

::: {.column width="50%"}
```{python}
#| label: py-lst-mutable1
#| echo: true

lst[1]
lst[1] = "stats"
lst
```
:::


::: {.column width="50%"}
```{python}
#| label: py-lst-mutable2
#| echo: true
lst[2:] = [False, 77]
lst
```
:::
::::


::: notes
If we change any element value in a list, the list itself will be changed as well.
:::


## List Operations and Methods `list.method()`

:::: {.columns}

::: {.column width="50%"}
```{python}
#| label: py-lst-operation
#| echo: true

## Concatenation
lst_num + lst
```

```{python}
#| echo: true
## Repetition
lst_num * 3 
```


```{python}
#| echo: true
## Membership
34 in lst
```

:::


::: {.column width="50%"}
```{python}
#| label: py-lst-method
#| echo: true

## Appends "cat" to lst
lst.append("cat")
lst
```


```{python}
#| echo: true
## Removes and returns last object from list
lst.pop()
lst
```

```{python}
#| echo: true
## Removes object from list
lst.remove("stats")
lst
```


```{python}
#| echo: true
## Reverses objects of list in place
lst.reverse()
lst
```

:::
::::



::: notes
This is a common syntax in Python. We start with a Pyhton object of some type, then type dot followed by any method specifically for this particular data type or structure for operations.
list.pop(index)
:::

## Tuples

- **Tuples** work exactly like lists except they are **immutable**, i.e., they can't be changed in place.

- To create a tuple, we use `()`.


:::: {.columns}

::: {.column width="50%"}
```{python}
#| label: py-tuple
#| echo: true
tup = ('data', 'math', 34, True)
tup
type(tup)
len(tup)
```
:::


::: {.column width="50%"}
```{python}
#| label: py-tuple1
#| echo: true
tup[2:]
tup[-2]
```

```{python}
#| echo: true
#| eval: false
tup[1] = "stats"  ## does not work!
# TypeError: 'tuple' object does not support item assignment
```

```{python}
#| echo: true
tup
```

:::
::::


:::notes
'tuple' object does not support item assignment
:::

## Tuples Functions and Methods

```{python}
#| echo: true

# Converts a list into tuple
tuple(lst_num)
```

```{python}
#| echo: true

# number of occurance of "data"
tup.count("data")
```

```{python}
#| echo: true

# first index of "data"
tup.index("data")
```



:::{.callout-note}

:::{style="font-size: 1.3em;"}
Lists have more methods than tuples because lists are more flexible.
:::

:::


## Dictionaries

- A **dictionary** consists of [*key-value pairs*]{style="color:green"}.

- A dictionary is mutable, i.e., the values can be changed in place and more key-value pairs can be added.

- To create a dictionary, we use `{"key name": value}`.

- The value can be accessed by the key in the dictionary. 

```{python}
#| echo: true
dic = {'Name': 'Ivy', 'Age': 7, 'Class': 'First'}
```

```{python}
#| echo: true
dic['Age']
```

```{python}
#| echo: true
#| eval: false
dic['age']  ## does not work
```


```{python}
#| echo: true
dic['Age'] = 9
dic['Class'] = 'Third'
dic
```



## Properties of Dictionaries

- Python will use the last assignment!

```{python}
#| echo: true
dic1 = {'Name': 'Ivy', 'Age': 7, 'Name': 'Liya'}
dic1['Name']
```

. . .

- Keys are [*unique and immutable*]{style="color:green"}. 

- A key can be a tuple, but CANNOT be a list.

```{python}
#| echo: true

## The first key is a tuple!
dic2 = {('First', 'Last'): 'Ivy Lee', 'Age': 7}
dic2[('First', 'Last')]
```


```{python}
#| echo: true
#| eval: false

## does not work
dic2 = {['First', 'Last']: 'Ivy Lee', 'Age': 7}
dic2[['First', 'Last']]
```


## Disctionary Methods

```{python}
dic
```

```{python}
#| echo: true

## Returns list of dictionary dict's keys
dic.keys()
```

<br>

. . .

```{python}
#| echo: true

## Returns list of dictionary dict's values
dic.values()
```

<br>

. . .

```{python}
#| echo: true

## Returns a list of dict's (key, value) tuple pairs
dic.items()
```

<br>

. . .

```{python}
#| echo: true

## Adds dictionary dic2's key-values pairs in to dic
dic2 = {'Gender': 'female'}
dic.update(dic2)
dic
```


::: notes

```{python}
#| echo: true

## Removes all elements of dictionary dict
dic.clear()
dic
```

:::

##
:::{.lab}

<span style="color:blue"> **06-Python Data Structure** </span>

In **lab.qmd** Lab 6,

- Create a Python list and dictionary similar to the R list below.

```{r}
#| echo: true
#| eval: false
x_lst <- list(idx = 1:3, 
              "a", 
              c(TRUE, FALSE))
```

Remember to create Python code chunk

```{Python}
#| echo: fenced
#| eval: true

```

[Any issue of this Python chunk?]{.red}


Commit and Push your work once you are done.
:::







## Python Data Structures for Data Science

- Python built-in data structures are not specifically for data science.

- To use more data science friendly functions and structures, such as array or data frame, Python relies on packages [`NumPy`](https://numpy.org/) and [`pandas`](https://pandas.pydata.org/).



:::: {.columns}



::: {.column width="50%"}
```{r}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/3/31/NumPy_logo_2020.svg")
```


:::


::: {.column width="50%"}
```{r}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/e/ed/Pandas_logo.svg")
```
:::
::::


## Installing NumPy and pandas*
In your **lab-yourusername** project, run
```{r}
#| echo: true
#| eval: false
library(reticulate)
virtualenv_create("myenv")
```


. . .

Go to **Tools > Global Options > Python > Select > Virtual Environments**

```{r}
#| out-width: "50%"
knitr::include_graphics("./images/06-syntax/python-env.png")
```



## Installing NumPy and pandas*

You may need to restart R session. Do it, and in the new R session, run

```{r}
#| echo: true
#| eval: false
library(reticulate)
py_install(c("numpy", "pandas", "matplotlib"))
```

. . .


Run the following Python code, and make sure everything goes well.

```{python}
#| echo: true
#| eval: false
import numpy as np
import pandas as pd
v1 = np.array([3, 8])
v1
df = pd.DataFrame({"col": ['red', 'blue', 'green']})
df
```




# Descriptive Statistics (MATH 4720)

- ### Central Tendency and Variability
- ### Data Summary


## Central Tendency: Mean and Median

:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```


```{r}
#| echo: true
data <- c(3,12,56,9,230,22)
mean(data)
median(data)  
```


:::


::: {.column width="50%"}
::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```


```{python}
#| echo: true

data = np.array([3,12,56,9,230,22])
type(data)
np.mean(data)
np.median(data)
```

:::
:::
::::


::: notes
- The **(arithmetic) mean** or average is adding up all of the values, then dividing by the total number of them.
- Mean balances data Values.
- The **median** is the middle value when data values are arranged from the lowest to highest.
- Mean is sensitive to extreme values (outliers).
:::




## Variation

:::: {.columns}

::: {.column width="50%"}


```{r}
#| out-width: "10%"
#| fig-align: "center"
knitr::include_graphics("./images/01-syllabus/Rlogo.png")
```


```{r}
#| echo: true
#| label: quantile
quantile(data, c(0.25, 0.5, 0.75)) 
```

```{r}
#| echo: true
#| label: var
var(data)
sd(data)
```

```{r}
#| echo: true
#| label: summary
summary(data)
```


:::


::: {.column width="50%"}
::: {.fragment}
```{r}
#| out-width: "7%"
#| fig-align: "center"
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg")
```

```{python}
#| echo: true
np.quantile(data,  [0.25, 0.5, 0.75])
```


```{python}
#| echo: true
np.var(data, ddof = 1)
np.std(data, ddof = 1)
```

```{python}
#| echo: true
df = pd.Series(data)
df.describe()
```

:::
:::
::::

::: notes
- **p-th percentile**: a data value such that at most $p\%$ of the data values are below it and at most $(1−p)\%$ of the values are above it.
- **First Quartile (Q1)**: the 25-th percentile
- **Second Quartile (Q2)**: the 50-th percentile (Median)
- **Third Quartile (Q3)**: the 75-th percentile
- **Interquartile Range (IQR)**: Q3 - Q1
IQR(data)
```{python}
#| echo: true
q75, q25 = np.percentile(data, [75 ,25])
q75 - q25
```
Delta Degrees of Freedom.
:::



# Basic Plotting

- ### Scatter Plot
- ### Boxplot
- ### Histogram
- ### Bar Chart
- ### Pie Chart
- ### 2D Imaging
- ### 3D Plotting


## R `plot()`

:::: {.columns}

::: {.column width="50%"}
```{r}
#| echo: true
#| label: mtcars
#| out-width: "38%"
#| class-output: "my_class600"
mtcars[1:15, 1:4]
```
:::


::: {.column width="50%"}
```{r}
#| echo: true
#| label: scatter
plot(x = mtcars$mpg, y = mtcars$hp, 
     xlab  = "Miles per gallon", 
     ylab = "Horsepower", 
     main = "Scatter plot", 
     col = "red", 
     pch = 5, las = 1)
```
:::
::::

## Argument pch 


```{r}
plot(x = 1:25, y = rep(1, 25), pch = 1:25, xlab = "", ylab = "", main = "pch", axes = FALSE)
axis(1, at = 1:25, cex.axis = 0.5)
```

- The defualt is pch = 1



## Python `matplotlib.pyplot`

:::: {.columns}

::: {.column width="50%"}
```{python}
#| echo: true
#| out-width: "38%"
#| class-output: "my_class600"
#| code-fold: true
mtcars = pd.read_csv('./data/mtcars.csv')
mtcars.iloc[0:15,0:4]
```
:::


::: {.column width="50%"}
```{python}
#| echo: true

import matplotlib.pyplot as plt
plt.scatter(x = mtcars.mpg, 
            y = mtcars.hp, 
            color = "r")
plt.xlabel("Miles per gallon")
plt.ylabel("Horsepower")
plt.title("Scatter plot")
```
:::
::::

## Python Subplots

:::{.callout-note}

:::{style="font-size: 1.2em;"}
The command `plt.scatter()` is used for creating one single plot. If multiple subplots are wanted in one single call, one can use the format
```{python}
#| echo: true
#| eval: false
fig, (ax1, ax2) = plt.subplots(1, 2)
ax1.scatter(x, y)
ax2.plot(x, y)
```

:::
:::

- Check [Creating multiple subplots using `plt.subplots`](https://matplotlib.org/stable/gallery/subplots_axes_and_figures/subplots_demo.html) for more details.

## R Subplots

```{r}
#| echo: true

par(mfrow = c(1, 2))
plot(x = mtcars$mpg, y = mtcars$hp, xlab = "mpg")
plot(x = mtcars$mpg, y = mtcars$weight, xlab = "mpg")
```


## R `boxplot()`

:::: {.columns}
::: {.column width="50%"}
```{r}
#| echo: true
#| fig-show: hide
#| label: boxplot
#| warning: false
boxplot(mpg ~ cyl, 
        data = mtcars, 
        col = c("blue", "green", "red"), 
        las = 1, 
        horizontal = TRUE,
        xlab = "Miles per gallon", 
        ylab = "Number of cylinders")
```
:::
::: {.column width="50%"}
```{r ref.label = "boxplot"}
#| warning: false
par(mar = c(4, 4, 0, 0))
```
:::
::::

::: notes
- Visualizing relationships between numerical and categorical data, we can check side-by-side boxplots.
- For example, if we want to check the data variation of (miles per gallon) for each number of cylinder, we can use boxplot() function.
- And inside the function, we use the formula mpg ~ cyl, and specify the dataset. 
- That is basically it. The rest of arguments are decorating your plot. They are optional.
:::


## Python `boxplot()`

```{python}
#| echo: true
#| code-fold: true
cyl_index = np.sort(np.unique(np.array(mtcars.cyl)))
cyl_shape = cyl_index.shape[0]
cyl_list = []
for i in range (0, cyl_shape):
    cyl_list.append(np.array(mtcars[mtcars.cyl == cyl_index[i]].mpg))
```

```{python}
#| echo: true
#| label: boxplot-py
#| results: hide
#| out-width: "60%"
import matplotlib.pyplot as plt
plt.boxplot(cyl_list, vert=False, labels=[4, 6, 8])
plt.xlabel("Miles per gallon")
plt.ylabel("Number of cylinders")
```







## R `hist()`

- `hist()` decides the class intervals/with based on `breaks`. If not provided, R chooses one.

:::: {.columns}
::: {.column width="50%"}
```{r}
#| echo: true
#| label: hist
#| fig-show: hide
#| warning: false
hist(mtcars$wt, 
     breaks = 20, 
     col = "#003366", 
     border = "#FFCC00", 
     xlab = "weights", 
     main = "Histogram of weights",
     las = 1)
```
:::


::: {.column width="50%"}
```{r ref.label = "hist"}
#| out-width: "90%"
```
:::
::::


::: notes
- Besides color names, you can also use hex number to specify colors. Pretty handy.
:::


## Python `hist()`

```{python}
#| results: hide
#| echo: true
#| out-width: "60%"
plt.hist(mtcars.wt, 
         bins = 19, 
         color="#003366",
         edgecolor="#FFCC00")
plt.xlabel("weights")
plt.title("Histogram of weights")
```


## R `barplot()`

```{r}
#| echo: true
(counts <- table(mtcars$gear)) 
```

```{r barplot}
#| echo: true
#| label: barplot
#| warning: false
#| out-width: "60%"
my_bar <- barplot(counts, 
                  main = "Car Distribution", 
                  xlab = "Number of Gears", 
                  las = 1)
text(x = my_bar, y = counts - 0.8, 
     labels = counts, 
     cex = 0.8)
```


## Python `barplot()`

```{python}
#| echo: true
count_py = mtcars.value_counts('gear')
count_py
```

```{python}
#| echo: true
#| warning: false
#| out-width: "60%"
plt.bar(count_py.index, count_py)
plt.xlabel("Number of Gears")
plt.title("Car Distribution")
```


## R `pie()`

```{r}
#| echo: true
(percent <- round(counts / sum(counts) * 100, 2))
(labels <- paste0(3:5, " gears: ", percent, "%"))
```


```{r}
#| echo: true
#| label: pie
pie(x = counts, labels = labels,
    main = "Pie Chart", 
    col = 2:4, 
    radius = 1)
```


::: notes
- Pie charts are used for categorical variables, especially when we want to know percentage of each category.
- The first argument is the frequency table, and you can add labels to each category.
:::


## Python `pie()`

```{python}
#| echo: true
percent = round(count_py / sum(count_py) * 100, 2)
texts = [str(percent.index[k]) + " gear " + str(percent.array[k]) + "%" for k in range(0,3)]
```


```{python}
#| echo: true
#| results: hide
plt.pie(count_py, labels = texts, colors = ['r', 'g', 'b'])
plt.title("Pie Charts")
```


## R 2D Imaging: `image()`
- The `image()` function displays the values in a matrix using color.

:::: {.columns}

::: {.column width="50%"}

```{r image, fig.show = "hide", warning = FALSE}
#| echo: true
matrix(1:30, 6, 5)
image(matrix(1:30, 6, 5))
```
:::


::: {.column width="50%"}
```{r ref.label = "image", eval=2, echo = FALSE, warning = FALSE, out.width = "100%"}
```
:::
::::

. . .

In [Python](https://matplotlib.org/stable/plot_types/arrays/imshow.html#sphx-glr-plot-types-arrays-imshow-py),

```{python}
#| echo: true
#| eval: false
plt.imshow(mat_img, cmap='Oranges')
```


## R `fields::image.plot()`

:::: {.columns}

::: {.column width="50%"}

```{r imageplot, fig.show = "hide", warning = FALSE}
#| echo: true
library(fields)
str(volcano)
image.plot(volcano)
```
:::

::: {.column width="50%"}

```{r ref.label = "imageplot", eval=3, echo = FALSE, warning = FALSE, out.width = "100%", purl=FALSE}
```
:::
::::

## R 2D Imaging Example: Volcano

```{r}
x <- 10*(1:nrow(volcano))
y <- 10*(1:ncol(volcano))
image(x, y, volcano, col = hcl.colors(100, "terrain"), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
        add = TRUE, col = "brown")
axis(1, at = seq(100, 800, by = 100))
axis(2, at = seq(100, 600, by = 100))
box()
title(main = "Maunga Whau Volcano", font.main = 4)
```




## R 3D scatter plot: `scatterplot3d()`

:::: {.columns}

::: {.column width="50%"}

```{r 3dplot, fig.show = "hide", warning = FALSE}
#| echo: true
library("scatterplot3d")
scatterplot3d(x = mtcars$wt, 
              y = mtcars$disp, 
              z = mtcars$mpg, 
              main = "3D Scatter Plot", 
              xlab = "Weights", 
              ylab = "Displacement",
              zlab = "Miles per gallon", 
              pch = 16, 
              color = "steelblue")
```
:::


::: {.column width="50%"}

```{r ref.label = "3dplot", eval=2, echo = FALSE, warning = FALSE, out.width = "100%"}
```
:::
::::

. . .

In [Python](https://matplotlib.org/stable/plot_types/3D/scatter3d_simple.html),

```{python}
#| echo: true
#| eval: false
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
```


## R Perspective Plot: `persp()`

:::: {.columns}

::: {.column width="50%"}

```{r persp, fig.show = "hide", warning = FALSE}
#| echo: true
# Exaggerate the relief
z <- 2 * volcano      
# 10 meter spacing (S to N)
x <- 10 * (1:nrow(z))   
# 10 meter spacing (E to W)
y <- 10 * (1:ncol(z))   
par(bg = "slategray")
persp(x, y, z, 
      theta = 135, 
      phi = 30, 
      col = "green3", 
      scale = FALSE,
      ltheta = -120, 
      shade = 0.75, 
      border = NA, 
      box = FALSE)
```
:::



::: {.column width="50%"}

```{r ref.label = "persp", eval=47:8, echo = FALSE, warning = FALSE, out.width = "100%", purl=FALSE}
```
:::
::::


. . .

In [Python](https://matplotlib.org/stable/plot_types/3D/surface3d_simple.html),

```{python}
#| echo: true
#| eval: false
fig, ax = plt.subplots(subplot_kw={"projection": "3d"})
ax.plot_surface(X, Y, Z)
```


::: notes
- You can also generate a so-called perspective plot using the function persp().
- I don't use the function often. You can try it with different argument values, and see how it changes.

:::


##
:::{.lab}


<span style="color:blue"> **07-Plotting (Bonus question!)** </span>
<!-- - Create a R script named **lab04-basicplot.R** -->


In **lab.qmd** `## Lab 7`,

- For the `mtcars` data, use R or Python to 
  + make a scatter plot of `miles per gallon` vs. `weight`. Decorate your plot using arguments, `col`, `pch`, `xlab`, etc.
  
  + create a histogram of 1/4 mile time. Make it beautiful!
  
- Commit and Push your work once you are done.

```{python}
#| eval: false
#| echo: true
import pandas as pd
import matplotlib.pyplot as plt
mtcars = pd.read_csv('./data/mtcars.csv')
```

:::


- *Find your mate and work in pairs. *

- *Two volunteer pairs teach us how to make beautiful plots next Tuesday (Feb 13)!*

- *The presenters will be awarded a hex sticker! 😎*


## Resources

- [The R Graph Gallery](https://www.r-graph-gallery.com/)
- [matplotlib](https://matplotlib.org/stable/plot_types/index.html)

We will talk about data visualization in detail soon!


::: notes
https://stackoverflow.com/questions/43482191/matplotlib-axes-plot-vs-pyplot-plot
:::